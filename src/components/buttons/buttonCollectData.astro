<div>
  <button
    class="w-full rounded-md rounded-green-700 hover:bg-green-800 hover:text-white text-lg text-green-900 border-green-700 border-2 px-2 py-1"
    onclick="startCollectData()"
    id="collectData">Collect Data</button
  >
  <!-- <button -->
  <!--   class="w-full rounded-md rounded-green-700 hover:bg-green-800 hover:text-white text-lg text-green-900 border-green-700 border-2 px-2 py-1" -->
  <!--   onclick="setDataJS()" -->
  <!-- > -->
  <!--   TEST -->
  <!-- </button> -->
</div>
<script is:inline>
  var currentDataType = null; // 'time_domain' o 'frequency_domain'
  var partialDataBuffer = new ArrayBuffer(0);
  var timeDomainData = [];
  var frequencyDomainData = [];
  var markers = [
    "END",
    "TIME_DOMAIN",
    "END_TIME_DOMAIN",
    "FREQUENCY_DOMAIN",
    "END_FREQUENCY_DOMAIN",
  ];

  function onEventsBluetooth(dataBuffer, message) {
    if (message && markers.includes(message)) {
      console.log("Received data...", message);
      if (message === "TIME_DOMAIN") {
        console.log("Init data in time domain.");
        updateMessage(eventActive);
        currentDataType = "time_domain";
        timeDomainData = [];
        partialDataBuffer = new ArrayBuffer(0);
      } else if (message === "END_TIME_DOMAIN") {
        console.log("End data in time domain.");
        currentDataType = null;
        partialDataBuffer = new ArrayBuffer(0);
        pointWithCollectData[eventActive + "_W"] = timeDomainData;
        drawAxios(eventActive + "_W"), 100;
      } else if (message === "FREQUENCY_DOMAIN") {
        console.log("Init data in frequency domain.");
        updateMessage(eventActive);
        currentDataType = "frequency_domain";
        frequencyDomainData = [];
        partialDataBuffer = new ArrayBuffer(0);
      } else if (message === "END_FREQUENCY_DOMAIN") {
        console.log("End data in frequency domain.");
        currentDataType = null;
        partialDataBuffer = new ArrayBuffer(0);
        pointWithCollectData[eventActive + "_S"] =
          processSpectra(frequencyDomainData);
        drawAxios(eventActive + "_S"), 100;
        receivingData = false;

        if (eventActive != "NEXT_Z") {
          // call next function
          eventActive = eventActive.includes("_X") ? "NEXT_Y" : "NEXT_Z";
          writeOnCharacteristic(eventActive);
        } else {
          // set storage latest collect data
          setLocalStorageLatestCollectData();
        }
      }
    } else {
      // Asumir que son datos binarios
      if (
        currentDataType === "time_domain" ||
        currentDataType === "frequency_domain"
      ) {
        partialDataBuffer = concatBuffers(partialDataBuffer, dataBuffer.buffer);

        // Desempaquetar los doubles cuando tengamos suficientes bytes
        while (partialDataBuffer.byteLength >= 8) {
          const chunk = partialDataBuffer.slice(0, 8);
          partialDataBuffer = partialDataBuffer.slice(8);

          const miniDataView = new DataView(chunk);

          const value = miniDataView.getFloat64(0, true);

          if (currentDataType === "time_domain") {
            timeDomainData.push(value);
          } else if (currentDataType === "frequency_domain") {
            frequencyDomainData.push(value);
          }
        }
      } else {
        console.log("Datos binarios recibidos sin tipo especÃ­fico. Ignorando.");
      }
    }
  }

  function setDataJS() {
    const surveys = getMawoisWithCollectDataStore();

    surveys[0].points[0].NEXT_X_S = M_NEXT_X_S.map((coord) => +coord.y);
    surveys[0].points[0].NEXT_X_W = M_NEXT_X_W.map((coord) => +coord.y);

    saveMawoisWithCollectDataStore(surveys);
  }

  let timeOutChangeMawoiOrPoint = null;

  if (timeOutChangeMawoiOrPoint) {
    clearTimeout(timeOutChangeMawoiOrPoint);
  }

  let mawoisWithCollectData = [];
  let mawoiWithCollectData = {
    id: null,
    code: null,
    description: null,
    pointLength: 0,
    points: [],
  };
  let pointWithCollectData = {
    id: null,
    date: null,
    NEXT_X_W: [],
    NEXT_X_S: [],
    NEXT_Y_W: [],
    NEXT_Y_S: [],
    NEXT_Z_W: [],
    NEXT_Z_S: [],
  };
  var eventActive = "NEXT_X";

  function startCollectData() {
    clearTimeout(timeOutChangeMawoiOrPoint);

    if (!toggle.checked) {
      alert("Please turn on Bluetooth!");
      return;
    }

    const pointInStore = findPointInCollectData(pointSelect.value);
    if (pointInStore) {
      setBandsInformation(pointInStore.point);
    }

    mawoisWithCollectData = getMawoisWithCollectDataStore();

    let setVariables = getVariablesStore();
    if (!setVariables) {
      setVariablesDefault();
      setVariables = getVariablesStore();
    }

    if (MAWOI_SELECTED == null) {
      alert("Please select a mawoi!");
      return;
    }

    showLoading();
    updateMessage("Set variables");
    setTimeout(() => {
      writeOnCharacteristic("SET_SAMPLES=" + setVariables.samples);
      setTimeout(() => {
        writeOnCharacteristic("SET_NLINES=" + setVariables.lines);
        setTimeout(() => {
          writeOnCharacteristic("SET_NREVS=" + setVariables.revolution);
          setTimeout(() => {
            writeOnCharacteristic("SET_FMAX=" + setVariables.fmax);
            setTimeout(() => {
              writeOnCharacteristic("SET_RPM=" + setVariables.rpm);
              setTimeout(() => {
                hideLoading();
                processCollectData();
              }, 500);
            }, 500);
          }, 500);
        }, 500);
      }, 500);
    }, 0);
  }

  let idxMawoi = -1;

  function processCollectData() {
    drawClear();
    showLoading();
    let mawoiStore = getMawoiSelectedStore();

    idxMawoi = -1;
    if (mawoisWithCollectData && mawoisWithCollectData.length > 0) {
      idxMawoi = mawoisWithCollectData.findIndex(
        (mawoi) => mawoi.id === mawoiStore.id,
      );
    }

    if (idxMawoi >= 0) {
      mawoiWithCollectData = mawoisWithCollectData[idxMawoi];
    } else {
      mawoiWithCollectData.id = MAWOI_SELECTED.id;
      mawoiWithCollectData.code = MAWOI_SELECTED.code;
      mawoiWithCollectData.plantId = MAWOI_SELECTED.plantId;
      mawoiWithCollectData.description = MAWOI_SELECTED.description;
      const pointsLength = [
        ...new Set(
          MAWOI_SELECTED.points.map((point) => point.code.substr(0, 2)),
        ),
      ].length;
      mawoiWithCollectData.pointLength = pointsLength;
      mawoiWithCollectData.points = [];
    }

    const pointSelect = document.getElementById("point-select");
    pointWithCollectData.id = pointSelect.value;
    pointWithCollectData.date = new Date().getTime();
    pointWithCollectData.description =
      pointSelect.options[pointSelect.selectedIndex].text;

    const vars = getVariablesStore();
    if (vars) {
      pointWithCollectData.vars = vars;
    }

    showLoading();
    eventActive = "NEXT_X";
    writeOnCharacteristic("NEXT_X");
  }

  function saveOrUpdateBandInformationStore(bandInfoTemp) {
    const bandInfoIdx = searchBandInfoInStore(
      bandInfoTemp.mawoiId,
      bandInfoTemp.pointCode,
      bandInfoTemp.date,
    );

    if (bandInfoIdx < 0) {
      addBandsInfoToStore(bandInfoTemp);
    } else {
      updateBandsInfoStore(bandInfoIdx, bandInfoTemp);
    }
  }

  function calculateBandsInformationInCollectData(
    waveform_y,
    spectrum_y,
    pointInUse,
    FMAX,
    COORD,
  ) {
    const bandsInfo = Object.values(pointInUse.bandsInfo);
    const pointCode = pointInUse.code.substr(0, 2);
    let bandInfoTemp = {
      pointCode: pointCode + COORD,
    };
    let coords = [pointCode + "H", pointCode + "X"];
    if (COORD == "Y") {
      coords = [pointCode + "V", pointCode + "Y"];
    } else if (COORD == "Z") {
      coords = [pointCode + "A", pointCode + "Z"];
    }
    bandInfoTemp.crestFactor = roundedDecimal(crestFactor(waveform_y), 3);
    bandInfoTemp.pkTopk = roundedDecimal(peakToPeak(waveform_y).pkTopk, 3);
    bandInfoTemp.overall = roundedDecimal(calculateOverall(spectrum_y), 3);

    const bandsInfoX = bandsInfo.filter((band) =>
      coords.includes(band.pointCode),
    );

    bandsInfoX.forEach((band) => {
      const data = spectrum_y;
      let velocities = spectraVelocity(data);
      velocities = velocities.map((v, idx) => ({
        vs_measure_y: v,
        vs_measure_x: (idx * FMAX) / spectrum_y.length,
      }));

      const bandInfo = processBandsInfo(pointInUse.rpm, velocities, band);
      bandInfoTemp[bandInfo.biv_code] = roundedDecimal(bandInfo.biv_value, 3);
    });

    return bandInfoTemp;
  }

  function setBandsInformation(pointWithCollectData) {
    let pointInUse = findPointForCollectData(pointSelect.value);
    pointInUse = pointInUse.point;

    const vars = pointWithCollectData.vars;
    const FMAX = vars.fmax;

    let bandInfoTemp = {
      mawoiId: mawoiSelect.value,
      date: dateSelect.value,
    };

    saveOrUpdateBandInformationStore({
      ...bandInfoTemp,
      ...calculateBandsInformationInCollectData(
        pointWithCollectData.NEXT_X_W,
        pointWithCollectData.NEXT_X_S,
        pointInUse,
        FMAX,
        "X",
      ),
    });

    saveOrUpdateBandInformationStore({
      ...bandInfoTemp,
      ...calculateBandsInformationInCollectData(
        pointWithCollectData.NEXT_Y_W,
        pointWithCollectData.NEXT_Y_S,
        pointInUse,
        FMAX,
        "Y",
      ),
    });

    saveOrUpdateBandInformationStore({
      ...bandInfoTemp,
      ...calculateBandsInformationInCollectData(
        pointWithCollectData.NEXT_Z_W,
        pointWithCollectData.NEXT_Z_S,
        pointInUse,
        FMAX,
        "Z",
      ),
    });
  }

  function setLocalStorageLatestCollectData() {
    mawoiWithCollectData.points.push({ ...pointWithCollectData });
    if (idxMawoi >= 0) {
      mawoisWithCollectData[idxMawoi] = { ...mawoiWithCollectData };
    } else {
      mawoisWithCollectData.push({ ...mawoiWithCollectData });
    }

    saveMawoisWithCollectDataStore(mawoisWithCollectData);

    let plantMemory = getPlantsStore();
    plantMemory = plantMemory.filter(Boolean);
    if (plantMemory && plantMemory.length > 0) {
      createHierarchyList(plantMemory);
      setDateByMawoiId(mawoiWithCollectData.id, pointWithCollectData.id);
    }

    hideLoading();
    validateIfAllPointsAreCollected();
  }

  function nextPointToCollect() {
    const _mawoiSelect = getMawoiSelectedStore();
    const _mawoisWithCollectData = getMawoisWithCollectDataStore();
    let pointsValidate = [];
    let idx = -1;
    if (_mawoisWithCollectData && _mawoisWithCollectData.length > 0) {
      idx = _mawoisWithCollectData.findIndex(
        (mawoi) => mawoi.id == _mawoiSelect.id,
      );
      if (idx >= 0) {
        const mawoiStoreValidate = _mawoisWithCollectData[idx];
        pointsValidate = mawoiStoreValidate.points.map(
          (point) => point.description,
        );
        pointsValidate = [...new Set(pointsValidate)];
      }
    }
    let nextPoint = null;
    const uniquePoint = uniquePoints();
    if (idx >= 0) {
      for (let point of uniquePoint) {
        if (!pointsValidate.includes(point)) {
          nextPoint = getPointInMawoiSelect(point);
          break;
        }
      }
    } else {
      nextPoint = _mawoiSelect.points[0];
    }
    return nextPoint;
  }

  function nextMawoiToCollect() {
    const _mawoisWithCollectData = getMawoisWithCollectDataStore();
    let mawoisValidate = _mawoisWithCollectData.map((mawoi) => mawoi.id);
    const plantMemory = getPlantsStore();
    let mawoiUnique = [];
    for (let plant of plantMemory) {
      for (let area of plant.areas) {
        for (let system of area.systems) {
          for (let mawoi of system.mawois) {
            if (!mawoisValidate.includes(mawoi.id)) {
              mawoiUnique.push(mawoi.id);
            }
          }
        }
      }
    }
    mawoisValidate = [...new Set(mawoisValidate)];

    let nextMawoi = null;
    for (let mawoi of mawoiUnique) {
      if (!mawoisValidate.includes(mawoi)) {
        nextMawoi = mawoi;
        break;
      }
    }
    return nextMawoi;
  }

  // validate if all points are collected
  // when all points are collected, next mawoi empty
  function validateIfAllPointsAreCollected() {
    const awaitTimeStorage = getAwaitTimeStore();
    const valueAwaitTime = awaitTimeStorage.value;
    const checkedAwaitTime = awaitTimeStorage.checked;

    const nextPoint = nextPointToCollect();
    const nextMawoi = nextMawoiToCollect();

    if (nextPoint && nextPoint.id && checkedAwaitTime) {
      pointSelect.value = nextPoint.id;
      timeOutChangeMawoiOrPoint = setTimeout(() => {
        showLoading();
        updateMessage("Next point ...");
        handleChangePoint();
        hideLoading();
      }, valueAwaitTime * 1000);
    } else if (nextMawoi && checkedAwaitTime) {
      mawoiSelect.value = nextMawoi;
      timeOutChangeMawoiOrPoint = setTimeout(() => {
        showLoading();
        updateMessage("Next mawoi...");
        handleChangeMawoi();
        hideLoading();
      }, valueAwaitTime * 1000);
    }
  }

  function uniquePoints() {
    const _mawoiSelect = getMawoiSelectedStore();
    if (!_mawoiSelect) {
      return [];
    }
    const points = _mawoiSelect.points.map((point) => point.code.substr(0, 2));

    return [...new Set(points)];
  }

  function getPointInMawoiSelect(code) {
    const _mawoiSelect = getMawoiSelectedStore();
    return _mawoiSelect.points.find((point) => point.code.includes(code));
  }
</script>
